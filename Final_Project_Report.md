

# Introduction:
For our final project we decide to implement an airport search program that enables users to traverse the graph using the BFS algorithm, calculate the shortest distance between two arbitrary airports based on user inputs, and display the corresponding centrality for individual airports within a subgraph.

# Adjacency Matrix:
The two dimensional vector we establish in the main.cpp resembles the square-shaped adjacency matrix that will be utilized in all algorithms, where the size of matrix counterparts the total number of airports presented in airport.dat file and each position of the matrix displays the connectivity between two airports as well as their geographical distance that computed by Great Circle Formula. In the main class, we develop various functions to extract information from routes.dat file to match each source airpot with the destination airport and insert the edge into the appropriate position. (only insert an edge when a route is present between two airports.)
However, the limited information contained in the routes.dat will result in a big proportion of zero distance present in our graph.

# BFS Traversal:
The BFS class consists of a copy of our adjacency matrix, a vector of booleans to track whether a specific airport has been visited, as well as a vector (which acts effectively as a queue) to record the traversed path of the BFS algorithm. After initialization, the algorithm pushes the user desired startpoint into the vector and repeatedly checks whether the startpoint has an edge with other points on the adjacency matrix. During the process, if a related point is connected with the startpoint but marked unvisited in the boolean vector, it will be pushed to the path vector. Then, the repeating process of popping and adding elements into the path vector will enable the user to traverse all the related airports from the startpoint. By incorporating BFS traversal with our main program, we discover a surprising fact that the graph is not completely connected as it has a very large connected component of size 3166 and other scattered components with smaller sizes. Again, we believe the underlying reason is the insufficient number of edges that are contained in the adjacency matrix since it is nearly impossible for the routes file to record all the air routes.

# Dijkstra Algorithm:
The first graph algorithm we built is the Dijkstra Algorithm that uses the adjacency matrix with user-defined start and destination point as input and produces the shortest distance between these two airports. To run our algorithm, the adjacency matrix is copied to the dijkstra class.  Firstly, we create a boolean vector, called TSET, to track all the vertices in the graph. We also initialize a distance vector with all default distance values setted to 1000000, except for the source index, which is set to 0. When the program encounters a vertex k that has a minimum distance value, but is not included in the SET, it would add k to the boolean set, and update the distance values by iterating through all the adjacent vertices of k. Originally, we think the running time of our algorithm would be O(|E| + |V|log|V|), but in our actual implementation, the running time turns out to be O(|V|2) respectively. From my perspective, the dijkstra algorithm works very successfully for our program as we tested the program with Beijing as a startpoint and Brazil as an endpoint. In the adjacency matrix, there is no direct connecting edge between these two airports. However, the dijkstra outputs the shortest distance between these two airports that matches exactly with the geographical distance between Beijing and Brazil in the world map.

# Betweenness Centrality:

The betweenness centrality algorithm allows us to determine the importance of each airport by weighting it through the number of shortest paths that passes through a given node. Originally we were going to implement another shortest path algorithm but after some brain storming we thought it would be more interesting if we could add upon our given algorithm to achieve the same goal. We decided to implement our betweenness centrality algorithm by modifying our dijkstra’s shortest path algorithm and adding a back tracking method that given a input node (or in our case an airport id) it keeps track of all the times each individual node has been traversed as a part of a shortest path in regard to the given input node. By looping through the entire graph, we are able to calculate the weights of each individual airport and store it as a 1D vector for our later visualization use. Note that the runtime is still O(|V|^3) since we are effective looping through the entire vertex (runtime of |V|) and with each iteration running our modified dijkstra’s algorithm (runtime of |V|^2).

# Visual Demonstration:

Taking the results of our shortest path and betweenness centrality, we are able to project a general shortest path onto a world map with the centrality weight being reflected by the size of the individual circles (here representing airports). We used the Mercator projection algorithm to draw airlines on a Mercator map. First, running the Dijkstra class, we are able to get a list that contains the airport(s) on an airline by order. Then the drawPoint() functions in the Projection class will be utilized to plot the airport(s) as dot(s). The function takes an Airport object as well as a double for centrality. A high centrality would result in a big point representing the associted airport. After that, function drawLine() would be called to connect the airports by lines. Our 2D map is Atalantic-centered, so the airlines flying over the Pacific would be drawn toward the outside of the map. 

